<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8"/>
  <title>Frame</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    #animation {
      width: 30px;
      height: 30px;
      background: red;
      animation: myfirst 3s infinite alternate;
    }

    @keyframes myfirst {
      from {
        width: 30px;
        height: 30px;
        border-radius: 0;
        background: red;
      }

      to {
        width: 300px;
        height: 300px;
        border-radius: 50%;
        background: yellow;
      }
    }
  </style>
</head>

<body>
<div style="height: 500px;">
  <div id="animation">test</div>
</div>
<button id="schedule">
  schedule
</button>


<script>
  // *平均用时 2ms
  function work() {
    const start = Date.now();

    while (Date.now() - start < 2) {
    }
  }

  function createWorks(length) {
    return new Array(length).fill(0).map(() => {
      return work;
    })
  }

  const works = createWorks(3000);

  const yieldInterval = 5;
  let deadLine = 0;
  const channel = new MessageChannel();
  let port = channel.port2;
  channel.port1.onmessage = performWorkUntilDeadLine;
  let scheduledHostCallback = null;

  let taskQueue = [];
  let isHostCallbackScheduled = false;

  function performWorkUntilDeadLine() {
    if (scheduledHostCallback) {
      const currentTime = Date.now();
      deadLine = currentTime + yieldInterval;
      const hasMoreWork = scheduledHostCallback(currentTime);
      if (!hasMoreWork) {
        scheduledHostCallback = null
      } else {
        port.postMessage(null);
      }
    }
  }

  function requestHostCallback(callback) {
    scheduledHostCallback = callback;
    port.postMessage(null);

  }

  // *schedule 使用的是最小堆，我这里就直接使用 sort 了
  function push(queue, task) {
    queue.push(task);
    queue.sort((a, b) => {
      return a.sortIndex - b.sortIndex;
    })
  }

  let taskIdCounter = 1;

  const ImmediatePriority = 1;
  const UserBlockingPriority = 2;
  const NormalPriority = 3;
  const LowerPriority = 4;
  const IdlePriority = 5;

  const IMMEDIATE_PRIORITY_TIMEOUT = -1;
  const USER_BLOCKING_PRIORITY_TIMEOUT = 250;
  const NORMAL_PRIORITY_TIMEOUT = 5000;
  const LOWER_PRIORITY_TIMEOUT = 10000;
  const IDLE_PRIORITY_TIMEOUT = 1073741823;// Math.pow(2, 30) - 1

  function scheduleCallback(priorityLevel, callback) {
    let timeout;
    switch (priorityLevel) {
      case ImmediatePriority:
        timeout = IMMEDIATE_PRIORITY_TIMEOUT;
        break;
      case UserBlockingPriority:
        timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
        break;
      case LowerPriority:
        timeout = LOWER_PRIORITY_TIMEOUT;
        break;
      case IdlePriority:
        timeout = IDLE_PRIORITY_TIMEOUT;
        break;
      case NormalPriority:
      default:
        timeout = NORMAL_PRIORITY_TIMEOUT;
        break;
    }
    const startTime = Date.now();
    const expiredTime = startTime + timeout;
    let newTask = {
      id: taskIdCounter++,
      startTime,
      callback: callback,
      priorityLevel,
      expiredTime,
      sortIndex: expiredTime
    }

    // *使用 push 方法可以每次添加新任务时都进行排序，高优先级任务插队就是这样的插的；
    push(taskQueue, newTask);

    if (!isHostCallbackScheduled) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    }
    return newTask;
  }

  let currentTask = null;

  function flushWork(initialTime) {
    return workLoop(initialTime)
  }

  // *添加了优先级后，workLoop 应该判断当前任务是否过期，如果过期了，即使应该 yield 也要继续将该任务执行完成；
  function workLoop(initialTime) {
    const currentTime = initialTime;
    currentTask = taskQueue[0];
    while (currentTask) {
      const isExpired = currentTime > currentTask.expiredTime;
      if (!isExpired && shouldYield()) {
        break;
      }
      const callback = currentTask.callback;
      // !注意：此次引入了优先级的概念，如果在 callback 中调度了高优先级的任务，那么就会插入到堆顶，需要对这种情况进行处理；
      if (typeof callback === 'function') {
        currentTask.callback = null;
        const continuationCallback = callback(isExpired);
        if (currentTask === taskQueue[0]) {
          taskQueue.shift();
        }

      } else {
        taskQueue.shift();
      }

      currentTask = taskQueue[0];
    }
    if (currentTask) {
      return true;
    } else {
      isHostCallbackScheduled = false;
      return false;
    }
  }

  const btn = document.getElementById("schedule");
  const div = document.getElementById("animation");
  btn.addEventListener('click', () => {
    const last = works.length - 1;
    const start = Date.now();
    works.forEach((work, i) => {
      scheduleCallback(() => {
        if (i === last) {
          work();
          div.textContent = `${Date.now() - start}ms`;
        } else work();
      })
    })
  })
</script>
</body>

</html>
