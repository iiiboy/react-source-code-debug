## è°ƒåº¦ä¸è°ƒå’Œ

åœ¨å…¶ä»–çš„å¾ˆå¤šä»£ç ï¼Œéƒ½ç©¿æ’äº† schedule æ‰€ä»¥éœ€è¦å¥½å¥½åœ°ç ”ç©¶ä¸€ä¸‹è°ƒåº¦å’Œè°ƒå’Œæ‰è¡Œ

å¯ä»¥å…ˆçœ‹ä¸€ä¸‹[æ³¨æ„](#æ³¨æ„)é‡Œé¢çš„ç¬¬ä¸€ç‚¹ï¼Œè¦æ‰“å¼€å¼‚æ­¥æ›´æ–°çš„è¯éœ€è¦ä½¿ç”¨ `createRoot`, å¯¹äº `reactDOM.render` è¿˜æ˜¯é»˜è®¤ä½¿ç”¨åŒæ­¥çš„æ›´æ–°çš„ï¼Œä¹Ÿå°±æ˜¯ v15 ä¹‹å‰çš„è¡Œä¸ºã€‚

æ³¨æ„ï¼šä»¥ä¸‹å†…å®¹æš‚æ—¶ä¸º v17 ç‰ˆæœ¬ã€‚

### å‚è€ƒèµ„æ–™

1. å°å†Œ -> [åŸç†ç¯‡-è°ƒåº¦](https://juejin.cn/book/6945998773818490884/section/7031002697515925545)
2. github -> https://github.com/neroneroffy/react-source-code-debug/blob/master/docs/%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6/Scheduler.md
3. [**ä¼˜å…ˆçº§ + ä½è¿ç®—**](https://juejin.cn/post/7039961115803009055)

### ä¼˜å…ˆçº§

åœ¨ react ä¸­ä¸»è¦åˆ†ä¸ºä¸¤ç±»ä¼˜å…ˆçº§ï¼š`scheduler ä¼˜å…ˆçº§` å’Œ `lane ä¼˜å…ˆçº§`

å› ä¸º react ä¸æ­¢é’ˆå¯¹äº web ç¯å¢ƒï¼Œæ¯”å¦‚è¿˜æœ‰ reactNativeï¼Œscheduler æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„åŒ…ï¼Œä¸“é—¨ç”¨äºè¿›è¡Œè°ƒåº¦ã€‚æ‰€ä»¥ scheduler æœ‰ä¸€å¥—è‡ªå·±çš„ä¼˜å…ˆçº§ã€‚

react ä¸­ä½¿ç”¨åœ¨æ–‡ä»¶ [SchedulerWithReactIntegration](src/react/v17/react-reconciler/src/SchedulerWithReactIntegration.old.js) ä¸­çš„å‡½æ•°è¿›è¡Œä¼˜å…ˆçº§çš„äº’ç›¸è½¬æ¢ã€‚

- [lane](src/react/v17/react-reconciler/src/ReactFiberLane.js) ä¼˜å…ˆçº§ï¼šä¸»è¦ç”¨äºä»»åŠ¡è°ƒåº¦å‰ï¼Œå¯¹å½“å‰æ­£åœ¨è¿›è¡Œçš„ä»»åŠ¡å’Œè¢«è°ƒåº¦ä»»åŠ¡åšä¸€ä¸ªä¼˜å…ˆçº§æ ¡éªŒï¼Œåˆ¤æ–­æ˜¯å¦éœ€è¦æ‰“æ–­å½“å‰æ­£åœ¨è¿›è¡Œçš„ä»»åŠ¡ï¼›
- `event ä¼˜å…ˆçº§`ï¼šæœ¬è´¨ä¸Šä¹Ÿæ˜¯laneä¼˜å…ˆçº§ï¼Œlaneä¼˜å…ˆçº§æ˜¯é€šç”¨çš„ï¼Œeventä¼˜å…ˆçº§æ›´å¤šæ˜¯ç»“åˆæµè§ˆå™¨åŸç”Ÿäº‹ä»¶ï¼Œå¯¹laneä¼˜å…ˆçº§åšäº†åˆ†ç±»å’Œæ˜ å°„
  ![eventPriorities](eventPriorities.jpg)
- [scheduler](src/react/v17/scheduler/src/SchedulerPriorities.js) ä¼˜å…ˆçº§ï¼šä¸»è¦ç”¨åœ¨æ—¶é—´åˆ†ç‰‡ä¸­ä»»åŠ¡è¿‡æœŸæ—¶é—´çš„è®¡ç®—

#### ä¼˜å…ˆçº§çš„è½¬æ¢

1. laneä¼˜å…ˆçº§ è½¬ eventä¼˜å…ˆçº§ï¼ˆå‚è€ƒ [lanesToEventPriority](src/react/v18/react-reconciler/src/ReactEventPriorities.old.js) å‡½æ•°ï¼‰
   - è½¬æ¢è§„åˆ™ï¼šä»¥åŒºé—´çš„å½¢å¼æ ¹æ®ä¼ å…¥çš„laneè¿”å›å¯¹åº”çš„ event ä¼˜å…ˆçº§ã€‚æ¯”å¦‚ä¼ å…¥çš„ä¼˜å…ˆçº§ä¸å¤§äº Discrete ä¼˜å…ˆçº§ï¼Œå°±è¿”å› Discrete ä¼˜å…ˆçº§ï¼Œä»¥æ­¤ç±»æ¨
2. eventä¼˜å…ˆçº§ è½¬ schedulerä¼˜å…ˆçº§ï¼ˆå‚è€ƒ [ensureRootIsScheduled](src/react/v18/react-reconciler/src/ReactFiberWorkLoop.old.js) å‡½æ•°ï¼‰
   - è½¬æ¢è§„åˆ™ï¼Œå¯ä»¥çœ‹ [æ–‡ç« ](https://juejin.cn/post/7039961115803009055) å¯¹åº”çš„ eventä¼˜å…ˆçº§ è¡¨ã€‚
3. eventä¼˜å…ˆçº§ è½¬ laneä¼˜å…ˆçº§ï¼ˆå‚è€ƒ [getEventPriority](src/react/v18/react-dom/src/events/ReactDOMEventListener.js) å‡½æ•°ï¼‰
   - è½¬æ¢è§„åˆ™ï¼šå¯¹äºéç¦»æ•£ã€è¿ç»­çš„äº‹ä»¶ï¼Œä¼šæ ¹æ®ä¸€å®šè§„åˆ™ä½œè½¬æ¢ï¼Œå…·ä½“å‚è€ƒä¸Šé¢ event ä¼˜å…ˆçº§è¡¨

### é—®é¢˜

1. [render](src/react/v17.0.0-alpha.0/react-dom/src/client/ReactDOMLegacy.js) æ—¶æ˜¯å¦‚ä½•ä» updateContainer è¿›å…¥ beginWork çš„ã€‚
2. [æ‰¹é‡æ›´æ–°](src/react/v17/react-reconciler/src/ReactFiberWorkLoop.old.js)åˆ°åº•æ˜¯å¦‚ä½•èµ·ä½œç”¨çš„ï¼Ÿä¸ºä»€ä¹ˆåœ¨ scheduleUpdateOnFiber ä¸­å¹¶æ²¡æœ‰çœ‹åˆ° isBatchingEventUpdatesï¼Ÿ
3. è°ƒåº¦å’Œè°ƒå’Œæ˜¯å¦‚ä½•ä¸­æ–­è¿›è¡Œä¸­çš„ä»»åŠ¡ï¼Œåˆæ˜¯å¦‚ä½•é‡å¯ä¹‹å‰è¢«ä¸­æ–­çš„ä»»åŠ¡çš„ï¼Ÿ

### legacy æ¨¡å¼

`reactDOM.render` ä½¿ç”¨çš„å°±æ˜¯ legacy æ¨¡å¼ï¼Œä¹Ÿå°±æ˜¯åŒæ­¥æ›´æ–°ã€‚

åœ¨ legacy æ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰çš„ä»»åŠ¡éƒ½æ˜¯ç´§æ€¥ä»»åŠ¡ï¼Œé‚£ä¹ˆåªéœ€è¦æŒ‰ç…§é¡ºåºè¿›è¡Œæ‰§è¡Œå°±è¡Œäº†ã€‚ä¹Ÿå¯ä»¥ç†è§£æˆæ²¡æœ‰ä¼˜å…ˆçº§çš„æ¦‚å¿µï¼Œæ‰€æœ‰çš„ Update éƒ½æŒ‰ç…§é¡ºåºè¿›è¡Œæ›´æ–°ã€‚

### concurrent æ¨¡å¼

éœ€è¦ä½¿ç”¨ `createRoot` å¼€å¯å¼‚æ­¥æ›´æ–°æ¨¡å¼ã€‚

åœ¨ concurrent æ¨¡å¼ä¸‹ï¼Œå°†ä¼šæŒ‰ç…§ä¼˜å…ˆçº§ä¼˜å…ˆåŠç†é«˜ä¼˜å…ˆçº§ä»»åŠ¡ï¼Œç„¶ååŠç†ä½ä¼˜å…ˆçº§ä»»åŠ¡ï¼›ä¸ºäº†ä¿è¯ä½ä¼˜å…ˆçº§ä»»åŠ¡çš„æ‰§è¡Œï¼Œä¹Ÿä¼šç»™ä½ä¼˜å…ˆçº§ä»»åŠ¡ä¸€ä¸ªè¿‡æœŸæ—¶é—´ï¼Œè¾¾åˆ°è¿‡æœŸæ—¶é—´æ—¶ï¼Œå°†ä¼šç ´æ ¼æ‰§è¡Œä½ä¼˜å…ˆçº§ä»»åŠ¡ã€‚

### é‡ç‚¹ schedulerUpdateOnFiber

schedulerUpdateOnFiber æ˜¯è°ƒåº¦çš„å…¥å£ï¼Œéå¸¸çš„é‡è¦ã€‚

```flow js
export function scheduleUpdateOnFiber(
  fiber: Fiber,
  lane: Lane,
  eventTime: number,
) {
  // *åˆ¤æ–­æ›´æ–°çš„åµŒå¥—æ¬¡æ•°ï¼Œå¦‚æœåµŒå¥—æ¬¡æ•°å¤ªå¤šï¼Œé‚£ä¹ˆå°±ä¼šæŠ›å‡ºé”™è¯¯ï¼›é¿å…æ— é™å¾ªç¯çš„æƒ…å†µï¼›ä¸€èˆ¬æƒ…å†µä¸‹åµŒå¥— 50 å±‚å°†ä¼šæŠ¥é”™ã€‚
  checkForNestedUpdates();
  warnAboutRenderPhaseUpdatesInDEV(fiber);

  // 1 å°†ä¼˜å…ˆçº§åˆå¹¶åˆ°å½“å‰ Fiber èŠ‚ç‚¹çš„ lanes å±æ€§ä¸­
  // 2 å°†ä¼˜å…ˆçº§åˆå¹¶åˆ°çˆ¶çº§èŠ‚ç‚¹çš„ childLanes å±æ€§ä¸­ï¼ˆå‘Šè¯‰çˆ¶èŠ‚ç‚¹ä»–çš„å­èŠ‚ç‚¹æœ‰å¤šå°‘æ¡èµ›é“è¦è·‘ï¼‰ æ³¨æ„ä½¿ç”¨äº† while å¾ªç¯ï¼Œæ˜¯åˆå¹¶åˆ°æ‰€æœ‰çš„çˆ¶çº§èŠ‚ç‚¹äº†
  // *è¯¦ç»†å†…å®¹åœ¨ğŸ‘‡
  const root = markUpdateLaneFromFiberToRoot(fiber, lane);
  // *root ä¸º null æ—¶åº”è¯¥æ˜¯ä¸æ­£ç¡®çš„æƒ…å†µï¼Œæ‰€ä»¥ç›´æ¥è¿”å› null
  if (root === null) {
    warnAboutUpdateOnUnmountedFiberInDEV(fiber);
    return null;
  }

  // Mark that the root has a pending update.
  markRootUpdated(root, lane, eventTime);

  if (root === workInProgressRoot) {
    // Received an update to a tree that's in the middle of rendering. Mark
    // that there was an interleaved update work on this root. Unless the
    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render
    // phase update. In that case, we don't treat render phase updates as if
    // they were interleaved, for backwards compat reasons.
    if (
      deferRenderPhaseUpdateToNextBatch ||
      (executionContext & RenderContext) === NoContext
    ) {
      workInProgressRootUpdatedLanes = mergeLanes(
        workInProgressRootUpdatedLanes,
        lane,
      );
    }
    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
      // The root already suspended with a delay, which means this render
      // definitely won't finish. Since we have a new update, let's mark it as
      // suspended now, right before marking the incoming update. This has the
      // effect of interrupting the current render and switching to the update.
      // TODO: Make sure this doesn't override pings that happen while we've
      // already started rendering.
      markRootSuspended(root, workInProgressRootRenderLanes);
    }
  }

  // TODO: requestUpdateLanePriority also reads the priority. Pass the
  // priority as an argument to that function and this one.
  // æ ¹æ®Schedulerçš„ä¼˜å…ˆçº§è·å–åˆ°å¯¹åº”çš„Reactä¼˜å…ˆçº§
  const priorityLevel = getCurrentPriorityLevel();

  if (lane === SyncLane) {
    if (
      // *æœ¬æ¬¡æ›´æ–°è¿˜åœ¨ 'æœªæ‰¹é‡æ›´æ–°' ä¸­
      // Check if we're inside unbatchedUpdates
      (executionContext & LegacyUnbatchedContext) !== NoContext &&
      // *ä¸”æœ¬æ¬¡æ›´æ–°ä¸æ˜¯ render æˆ– commit
      // Check if we're not already rendering
      (executionContext & (RenderContext | CommitContext)) === NoContext
    ) {
      // å¦‚æœæ˜¯æœ¬æ¬¡æ›´æ–°æ˜¯åŒæ­¥çš„ï¼Œå¹¶ä¸”å½“å‰æœªåœ¨æ¸²æŸ“æµç¨‹ä¸­ï¼Œé‚£ä¹ˆ
      // è°ƒç”¨performSyncWorkOnRootå¼€å§‹æ‰§è¡ŒåŒæ­¥ä»»åŠ¡

      // Register pending interactions on the root to avoid losing traced interaction data.
      schedulePendingInteractions(root, lane);// schedule pending interactions è°ƒåº¦å¾…å¤„ç†çš„äº¤äº’

      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed
      // root inside of batchedUpdates should be synchronous, but layout updates
      // should be deferred until the end of the batch.
      performSyncWorkOnRoot(root);// æ‰§è¡ŒåŒæ­¥ä»»åŠ¡
    } else {
      // å¦‚æœæ˜¯æœ¬æ¬¡æ›´æ–°æ˜¯åŒæ­¥çš„ï¼Œä½†æ˜¯å½“å‰å¤„åœ¨åŒæ­¥æ›´æ–°è¿‡ç¨‹ä¸­ï¼Œ
      // å› ä¸ºæ— æ³•æ‰“æ–­ï¼Œæ‰€ä»¥è°ƒç”¨ensureRootIsScheduled
      // ç›®çš„æ˜¯å»å¤ç”¨å·²ç»åœ¨æ›´æ–°çš„ä»»åŠ¡ï¼Œè®©è¿™ä¸ªå·²æœ‰çš„ä»»åŠ¡
      // æŠŠè¿™æ¬¡æ›´æ–°é¡ºä¾¿åšäº†
      ensureRootIsScheduled(root, eventTime);
      schedulePendingInteractions(root, lane);
      if (executionContext === NoContext) {
        // Flush the synchronous work now, unless we're already working or inside
        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of
        // scheduleCallbackForFiber to preserve the ability to schedule a callback
        // without immediately flushing it. We only do this for user-initiated
        // updates, to preserve historical behavior of legacy mode.
        resetRenderTimer();
        flushSyncCallbackQueue();
      }
    }
  } else {
    // Schedule a discrete update but only if it's not Sync.
    // åªåœ¨å¼‚æ­¥çš„æƒ…å†µä¸‹è°ƒåº¦ä¸€ä¸ªç¦»æ•£æ›´æ–°
    // rootsWithPendingDiscreteUpdatesåªä¸Reactçš„æµ‹è¯•ç”¨ä¾‹ç›¸å…³
    // å¯æš‚æ—¶å…ˆä¸å…³æ³¨
    if (
      (executionContext & DiscreteEventContext) !== NoContext &&
      // Only updates at user-blocking priority or greater are considered
      // discrete, even inside a discrete event.
      (priorityLevel === UserBlockingSchedulerPriority ||
        priorityLevel === ImmediateSchedulerPriority)
    ) {
      // This is the result of a discrete event. Track the lowest priority
      // discrete update per root so we can flush them early, if needed.
      if (rootsWithPendingDiscreteUpdates === null) {
        rootsWithPendingDiscreteUpdates = new Set([root]);
      } else {
        rootsWithPendingDiscreteUpdates.add(root);
      }
    }
    // Schedule other updates after in case the callback is sync.
    // å¦‚æœæ˜¯æ›´æ–°æ˜¯å¼‚æ­¥çš„ï¼Œè°ƒç”¨ensureRootIsScheduledå»è¿›å…¥å¼‚æ­¥è°ƒåº¦
    ensureRootIsScheduled(root, eventTime);
    schedulePendingInteractions(root, lane);
  }

  // We use this when assigning a lane for a transition inside
  // `requestUpdateLane`. We assume it's the same as the root being updated,
  // since in the common case of a single root app it probably is. If it's not
  // the same root, then it's not a huge deal, we just might batch more stuff
  // together more than necessary.
  mostRecentlyUpdatedRoot = root;
}
```

#### markUpdateLaneFromFiberToRoot

```flow js
// *æ›´æ–° fiber çš„ lanesï¼Œå¹¶ä¸”æ›´æ–°æ‰€æœ‰çˆ¶çº§ fiber çš„ childLanesï¼›æœ€åè¿”å› HostRoot
function markUpdateLaneFromFiberToRoot(
  sourceFiber: Fiber,
  lane: Lane,
): FiberRoot | null {
  // Update the source fiber's lanes
  // æ›´æ–°ç°æœ‰fiberä¸Šçš„lanes
  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
  // è·å–ç°æœ‰fiberçš„alternateï¼Œé€šè¿‡alternateæ˜¯å¦ä¸ºnullï¼Œæ¥åŒºåˆ†æ˜¯å¦æ˜¯æ›´æ–°è¿‡ç¨‹
  let alternate = sourceFiber.alternate;
  // å¦‚æœ alternate ä¸º null é‚£ä¹ˆè¯´æ˜å½“å‰ fiber åœ¨è§†å£ä¸­æ²¡æœ‰ã€‚
  if (alternate !== null) {
    // alternate.lanes ä¹Ÿè¦è¿›è¡Œæ›´æ–°
    alternate.lanes = mergeLanes(alternate.lanes, lane);
  }
  if (__DEV__) {
    if (
      alternate === null &&
      (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags
    ) {
      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
    }
  }
  // Walk the parent path to the root and update the child expiration time.
  // *ä»äº§ç”Ÿæ›´æ–°çš„fiberèŠ‚ç‚¹å¼€å§‹ï¼Œé€šè¿‡ while å¾ªç¯å‘ä¸Šæ”¶é›† childLanes
  // *åœ¨ç¬¬ä¸€æ¬¡ render é˜¶æ®µï¼Œnode å°±ç­‰äº HostRoot æ‰€ä»¥ä¸ä¼šè¿›å…¥ while å¾ªç¯
  let node = sourceFiber;
  let parent = sourceFiber.return;
  while (parent !== null) {
    // *ä¸ä¸Šé¢çš„æ–¹æ³•ä¸€æ ·ï¼Œä½†æ˜¯æ³¨æ„è¿™é‡Œæ›´æ–°çš„ä¸æ˜¯ lanes è€Œæ˜¯ childLanes
    parent.childLanes = mergeLanes(parent.childLanes, lane);
    alternate = parent.alternate;
    if (alternate !== null) {
      // *åŒæ ·çš„ alternate.childLanes ä¹Ÿè¦è¿›è¡Œæ›´æ–°
      alternate.childLanes = mergeLanes(alternate.childLanes, lane);
    } else {
      if (__DEV__) {
        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
        }
      }
    }
    // *ç„¶åæŒ‡å‘ parent
    node = parent;
    parent = parent.return;
  }
  if (node.tag === HostRoot) {
    const root: FiberRoot = node.stateNode;
    return root;
  } else {
    return null;
  }
}
```

#### markRootUpdated

ä¸»è¦ä½œç”¨ï¼š

1. å°† updateLane æ”¾å…¥ root.pendingLanes
2. å–æ¶ˆ root.suspendedLanes å’Œ root.pingedLanes ä¸­åŒç­‰æˆ–è€…ä½äº updateLane ä¼˜å…ˆçº§çš„æ›´æ–°
3. å°† updateLane å¯¹åº”çš„ eventTime æ”¾åˆ° root.eventTimes çš„å¯¹åº”ä½ç½®

```flow js
export function markRootUpdated(
  root: FiberRoot,
  updateLane: Lane,
  eventTime: number,
) {

  // å°†æœ¬æ¬¡æ›´æ–°çš„laneæ”¾å…¥rootçš„pendingLanes
  root.pendingLanes |= updateLane;

  // TODO: Theoretically, any update to any lane can unblock any other lane. But
  // it's not practical to try every single possible combination. We need a
  // heuristic to decide which lanes to attempt to render, and in which batches.
  // For now, we use the same heuristic as in the old ExpirationTimes model:
  // retry any lane at equal or lower priority, but don't try updates at higher
  // priority without also including the lower priority updates. This works well
  // when considering updates across different priority levels, but isn't
  // sufficient for updates within the same priority, since we want to treat
  // those updates as parallel.
  // ç†è®ºä¸Šï¼Œå¯¹ä»»ä½•laneçš„ä»»ä½•æ›´æ–°éƒ½å¯ä»¥è§£é™¤å¯¹å…¶ä»–laneçš„å°é”ã€‚ä½†æ˜¯å°è¯•æ¯ä¸€ä¸ªå¯èƒ½çš„ç»„åˆæ˜¯ä¸å®é™…çš„ã€‚
  // æˆ‘ä»¬éœ€è¦ä¸€ç§å¯å‘å¼ç®—æ³•æ¥å†³å®šæ¸²æŸ“å“ªäº›lanesè¦è¢«å°è¯•æ¸²æŸ“ï¼Œä»¥åŠåœ¨å“ªä¸ªæ‰¹æ¬¡ä¸­å¤„ç†å®ƒã€‚å½“å‰æ˜¯ç”¨çš„æ˜¯
  // ä¸ä¹‹å‰çš„è¿‡æœŸæ—¶é—´æ¨¡å¼ç›¸åŒçš„æ–¹å¼ï¼šå¯¹äºä¼˜å…ˆçº§ç›¸åŒæˆ–è€…è¾ƒä½çš„laneè¿›è¡Œé‡æ–°å¤„ç†ï¼Œä½†æ˜¯å¦‚æœæ²¡æœ‰åŒ…å«è¾ƒ
  // ä½ä¼˜å…ˆçº§çš„æ›´æ–°ï¼Œå°±ä¸ä¼šå»å¤„ç†é«˜ä¼˜å…ˆçº§çš„æ›´æ–°ã€‚å½“è€ƒè™‘è·¨ä¸åŒä¼˜å…ˆçº§çº§åˆ«çš„æ›´æ–°æ—¶ï¼Œè¿™ç§æ–¹æ³•å¾ˆåˆé€‚ï¼Œä½†
  // å¯¹äºç›¸åŒä¼˜å…ˆçº§çš„æ›´æ–°æ¥è¯´ï¼Œè¿™æ˜¯ä¸å¤Ÿçš„ï¼Œå› ä¸ºæˆ‘ä»¬å¸Œæœ›å¯¹è¿™äº›updateå¹¶è¡Œå¤„ç†ã€‚

  // ä¸Šé¢çš„æ„æ€æ˜¯ï¼Œç°æœ‰çš„lanesä¼˜å…ˆçº§æœºåˆ¶æ˜¯æ¨¡æ‹ŸexpirationTimeçš„ä¼˜å…ˆçº§æœºåˆ¶ï¼Œè‹¥åœ¨lanesä¸­å­˜åœ¨é«˜ä½ä¸¤ç§
  // ä¼˜å…ˆçº§çš„ä»»åŠ¡ï¼Œé‚£ä¹ˆä¼šåœ¨é«˜ä¼˜å…ˆçº§ä»»åŠ¡å®Œæˆåï¼Œå†å›æ¥åšä½ä¼˜å…ˆçº§çš„ä»»åŠ¡ã€‚æ¯”å¦‚lanes: 0b001100ï¼ŒReactä¼š
  // ä¼˜å…ˆå¤„ç†å€’æ•°ç¬¬ä¸‰ä¸ª1ï¼Œå®Œäº‹ä¹‹åå†å¤„ç†å€’æ•°ç¬¬å››ä¸ª1ï¼Œå¦‚æœè¿™ä¸¤ä¸ª1å±äºä¸åŒçš„ä¼˜å…ˆçº§çº§åˆ«å€’è¿˜å¥½è¯´ï¼Œæ¯”å¦‚å€’æ•°
  // ç¬¬ä¸‰ä¸ªæ˜¯Aä¼˜å…ˆçº§é›†åˆä¸­çš„ä¸€ä¸ªlaneï¼Œå€’æ•°ç¬¬å››ä¸ªæ˜¯Bä¼˜å…ˆçº§é›†åˆä¸­çš„ä¸€ä¸ªlaneï¼Œé‚£ä¹ˆè¿™æ˜¯è·¨ä¼˜å…ˆçº§å±‚çº§çš„æ­£å¸¸
  // æ›´æ–°è¡Œä¸ºï¼Œä½†æ˜¯å¦‚æœè¿™ä¸¤ä¸ª1éƒ½æ˜¯å±äºBä¼˜å…ˆçº§é›†åˆä¸­çš„laneï¼Œé‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œç°æœ‰çš„è¡Œä¸ºè¿˜æ˜¯æ²¿ç”¨ä¸Šé¢æåˆ°çš„
  // æ¨¡æ‹ŸexpirationTimeä¼˜å…ˆçº§æœºåˆ¶ä¸‹çš„æ›´æ–°è¡Œä¸ºï¼Œå³åšå®Œé«˜ä¼˜ä»»åŠ¡å›è¿‡å¤´é‡åšä½ä¼˜ä»»åŠ¡ï¼Œä½†æ˜¯Reactçš„å¸Œæœ›æ˜¯åœ¨
  // ä¸€æ¬¡æ›´æ–°ä»»åŠ¡ä¸­æŠŠä¸¤ä¸ª1éƒ½å¤„ç†æ‰ï¼Œæ‰€ä»¥è¿™é‡Œå†™äº†ä¸ªTodo

  // Unsuspend any update at equal or lower priority.
  // å–æ¶ˆåŒç­‰æˆ–è¾ƒä½ä¼˜å…ˆçº§çš„æ›´æ–°ã€‚

  const higherPriorityLanes = updateLane - 1; // Turns 0b1000 into 0b0111
  // (before) suspendedLanes 0b10100
  //                         &
  // higherPriorityLanes     0b10011
  // ----------------------------------
  // (after)  suspendedLanes 0b10000  è¿™æ ·å°±åªå‰©ä¸‹æ¯” 0b00100 é«˜çš„ä¼˜å…ˆçº§äº†ï¼Œ
  // å½“ suspendedLanes, pingedLanes è¿›è¡Œ & è¿ç®—æ—¶ï¼Œä¹Ÿå°±ä¼šå»æ‰è¿™ä¸¤ä¸ª lanes çš„ "åŒç­‰æˆ–è¾ƒä½ä¼˜å…ˆçº§"
  // å®ç°ä¸Šæ–¹æ³¨é‡Šä¸­çš„ â€œå–æ¶ˆåŒç­‰æˆ–è¾ƒä½ä¼˜å…ˆçº§çš„æ›´æ–°ã€‚â€
  root.suspendedLanes &= higherPriorityLanes;
  root.pingedLanes &= higherPriorityLanes;

  /**
   * *å‡è®¾ lanesï¼š0b000100
   * *é‚£ä¹ˆeventTimesæ˜¯è¿™ç§å½¢å¼ï¼š [ -1, -1, -1, 44573.3452, -1, -1 ]
   * *ç”¨ä¸€ä¸ªæ•°ç»„å»å­˜å‚¨eventTimesï¼Œ-1è¡¨ç¤ºç©ºä½ï¼Œé-1çš„ä½ç½®ä¸lanesä¸­çš„1çš„ä½ç½®ç›¸åŒ
   * */
  const eventTimes = root.eventTimes;// å› ä¸ºæœ‰ 31 æ¡èµ›é“ï¼Œæ‰€ä»¥ eventTimes æ˜¯ä¸€ä¸ª 31 é•¿åº¦çš„æ•°ç»„
  // *è®¡ç®—è·å¾— lane å¯¹åº”çš„ indexï¼Œä½è¿ç®—çš„è§£é‡Šå¯ä»¥çœ‹ è°ƒåº¦ä¸è°ƒå’Œ.md -> å‚è€ƒèµ„æ–™ç¬¬ä¸‰ä¸ª
  const index = laneToIndex(updateLane);
  // We can always overwrite an existing timestamp because we prefer the most
  // recent event, and we assume time is monotonically increasing.
  eventTimes[index] = eventTime;
}
```

### æ³¨æ„

åœ¨ react v17 ä¸­å¹¶ä¸ä¼šé»˜è®¤æ‰“å¼€**å¹¶å‘æ›´æ–°**ï¼Œå…·ä½“çš„å¯ä»¥çœ‹è¿™ç¯‡[æ–‡ç« ](https://juejin.cn/post/7031375070882693150)

æ³¨æ„ï¼šè™½ç„¶ v17 ä¸­æ²¡æœ‰é»˜è®¤æ‰“å¼€å¹¶å‘æ›´æ–°ï¼Œä½†æ˜¯é‡‡ç”¨çš„ä¾ç„¶æ˜¯ Fiber æ¶æ„ï¼Œæ‰€ä»¥å¹¶ä¸æ˜¯é€’å½’è¿›è¡Œæ›´æ–°çš„ï¼Œè€Œæ˜¯å¯ä¸­æ–­çš„æ›´æ–°ã€‚